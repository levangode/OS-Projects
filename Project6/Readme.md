###############
Final Project 6
###############
Team A
###############

პროგრამის გაშვების ინსტრუქცია:

1) make
2) ./ServerLauncher /path/to/configfile

დამხმარე ბიბლიოთეკებს არ საჭიროებს


პროგრამის აღწერა:

	Main features:
		* virtual-hosting
		* file transfer
		* CGI
		* log
		* html browsing

	მუშაობის პრინციპი:
		1)დასტარტვისას პროგრამა პარსავს კონფიგურაციის ფაილს და თითოეული ვირტუალური ჰოსტისთვის, რომლის სტრუქტურაც შემდეგნაირად გამოიყურება:
			struct virtual_server{
			char* vhost;
			char* documentroot;
			char* cgi_bin;
			char* ip;
			char* port;
			char* logg;
			struct sockaddr_in my_addr;
			int socket_fd;
		}; სტარტავს მომსახურე სრედს, რომელიც თავის მხრივ ქმნის სერვერის სოკეტს და ელოდება კლიენტების მიღებას იპოლით.
		იპოლი აკონტროლებს როგორც სერვერზე მოსულ ქონექშენებს, ასევე თითოეული დაკავშირებული კლიენტ სოკეტისგან გააქტიურებულ ივენთებს.
		სერვერ სოკეტის შემთხვევაში იძახებს accept-ს, ხოლო კლიენტის შემთხვევაში, სტარტავს მომსახურე სრედს, რომელიც recv-ით წაიკითხავს
		კლიენტისგან ინფორმაციას და მოემსახურება მას, საქმის ბოლოს კი გაითიშება და ქონექშენს დახურავს.
		იმ შემთხვევაში თუ keep-alive იყო მოსული, ეს სრედი კიდევ 5 წამის განმავლობაში დაელოდება(setsockopt RCVTIMEO flag) ახალი რიქუესთის მიღებას და იდენტურად მოემსახურება მას.

		###მნიშვნელოვანი!!! თუ იპოლის მუშაობას რაიმე დაუწუნეთ, server.c ში EPOLL დიფაინი 0-ად გადააკეთეთ და მულტისრედინგი მაინც იმუშავებს და მის მიხედვითაც შეგვაფასეთ. (ეს ჩვენი მხრიდან თავის დაზღვევაა უბრალოდ).

		2) რაც შეეხება თავად მომსახურებას:
		თითოეული ვირტუალური ჰოსტის სამუშაო დირექტორიები განსაზღვრულია ასევე კონფიგურაციის ფაილის მიხედვით. სერვერი ემსახურება მხოლოდ 
		.html, .jpg, .mp4 ფაილებს, ან დირექტორიებს. ფაილების გადასაგზავნად ვიყენებთ sendfile-ს, და ასევე ჰედერში ვუგზავნით შესაბამის კონტენტის ზომას და ტიპს.

		ყოველ მოთხოვნაზე სერვერი კლიენტს პასუხად უგზავნის შესაბამის სტატუს კოდს 200/404/304.

		ქეშის გასაკონტროლებლად კლიენტს ვუგზავნით ითაგს და მაქს-ეიჯ ჰედერს. ჰეშირებისთვის გამოვიყენეთ მარტივი ალგორითმი stat სტრუქტურის გამოყენებით, რომელიც მოიცავს აიონოუდის ნომერს, ფაილის ცვლილების თარიღს და მის ზომას.

		ფაილის ნაწყვეტ-ნაწყვეტ გასაგზავნად ვპარსავთ რეინჯ ჰედერს და ვუგზავნით შესაბამისი ბაიტების რეინჯს.

		სერვერზე სიჯიაი პროგრამა ეშვება ორ შემთხვევაში: პირველი, როდესაც url-ში ?-ის შემდეგ გადმოგვეცა გასაშვები არგუმენტები და მეორე, როცა კლიენტი მოგვმართავს POST მეთოდით. პოსტის შემთხვევაში პროგრამის არგუმენტებს ვკითხულობთ ბოდიდან და პროგრამას stdin-ში დაუმისამართდება პაიპით, ხოლო პროგრამის output-რომელიც ვალიდური http response უნდა იყოს, გადაეგზავნება ისევ კლიენტს (სოკეტით).

		ნებისმიერი მოთხოვნის შესაბამისად, ინფორმაცია ილოგება კონფიგით განსაზღვულ ფაილებში.

		3) ტექნიკური დეტალები:
		სტრინგების დასაპარსად გამოვიენეთ ტოკენაიზერი და strstr მეთოდი.
		მულტისრედინგისთვის გამოვიყენეთ POSIX-ის pthread
		ფაილის ინფოს მისაღებად გამოვიყენეთ stat
		ერორჰენდლინგი მაქსიმალურად გაწერილია, ნაწილი ინფორმაცია კონსოლში იბეჭდება, ნაწილი ასერტების სახით, ნაწილი ლოგში მიდის.

		:/ დანარჩენი დეტალები დავალების პირობაში წერია, კოდი პირობის შესაბამისია, არამგონია რიდმიში კიდე გავრცობას აზრი ჰქონდეს.
		დეკომპოზიციას რაც შეეხება, საჭირო დრო ამასაც დავახარჯეთ, მაგრამ შინაარსობრივად გამართული და გადაბმული მეთოდები ტყუილად არ 
		დავანაწევრეთ. თითო ფუნქციის ზომა იქნება მაქსიმუმ 40-60 ხაზი(თავის whitespace-ებიანად!!! :D).




